<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>340 Dashboard</title>

    <link rel="icon" type="image/png" href="/favicon.png">

    <style>
        ::-webkit-scrollbar {
            display: none;
        }

        body {
            margin: 0;
            padding: 0;
            color: white;
            background-color: #292929;
            font-family: 'Trebuchet MS', sans-serif;
            overflow: hidden;
        }

        body canvas {
            position: absolute;
            top: 0;
            z-index: 1000;
        }
    </style>
</head>

<body>
    <!-- Import libs -->
    <script src="/lib/networktables.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "./lib/three.module.js",
                "OrbitControls": "./lib/OrbitControls.module.js",
                "STLLoader": "./lib/STLLoader.module.js"
            }
        }
    </script>

    <!-- Shaders -->
    <script id="vertexShader" type="x-shader/x-vertex">
        attribute vec3 center;
        varying vec3 vCenter;

        void main() {
            vCenter = center;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">
        uniform float thickness;
        uniform vec3 color;
        varying vec3 vCenter;

        void main() {
            vec3 afwidth = fwidth(vCenter.xyz);
            vec3 edge3 = smoothstep((thickness - 1.0) * afwidth, thickness * afwidth, vCenter.xyz);
            float edge = 1.0 - min(min(edge3.x, edge3.y), edge3.z);
            gl_FragColor.rgb = gl_FrontFacing ? color : vec3(color.x * 0.5, color.y * 0.5, color.z * 0.5);
            gl_FragColor.a = edge;
        }
    </script>

    <!-- Logic -->
    <script type="module">
        const ENABLE_ORBIT_CONTROLS = false;
        const ENABLE_KEYBOARD_CONTROLS = true;

        import * as THREE from 'three';
        import { OrbitControls } from 'OrbitControls';
        import { STLLoader } from 'STLLoader'

        let scoring = null
        let currentFrustumScale = 1000;
        const currentSelection = {
            x: 0,
            y: 0
        };

        const loader = new STLLoader();

        const renderer = new THREE.WebGLRenderer({
            alpha: true,
            antialias: true
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const frustum = calculateCameraFrustum(currentFrustumScale);
        const camera = new THREE.OrthographicCamera(frustum.left, frustum.right, frustum.top, frustum.bottom, 1, 100);
        camera.position.z = 10;

        const scene = new THREE.Scene();

        if (ENABLE_ORBIT_CONTROLS) {
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enablePan = false;
            controls.enableZoom = true;
        }

        const coneSTL = await loadSTL(`./models/cone.stl`);
        const cubeSTL = await loadSTL(`./models/cube.stl`);

        const selectionOptions = [];
        for (let i = 0; i < 3; i++) {
            selectionOptions.push([]);
            for (let j = 0; j < 9; j++) {
                const mesh = j % 3 === 1 ? createMeshFromSTL(cubeSTL) : createMeshFromSTL(coneSTL);
                mesh.position.set((j * 0.75) - 3, (i * -0.5) + 1.55, 0);
                mesh.rotation.x = Math.PI / 6;
                mesh.rotation.y = -Math.PI / 6;
                scene.add(mesh);
                selectionOptions[i].push(mesh);
            }
        }

        const selectionOptionBackgrounds = [];
        for (let i = 0; i < 3; i++) {
            const mesh = new THREE.Mesh(roundedRectangle((i * 2.25) - 3.3125, 0.125, 2.125, 1.75, 0.2), new THREE.MeshBasicMaterial({
                color: i === 1 ? new THREE.Color(0x000000) : new THREE.Color(0x0000ff),
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            }));
            mesh.position.z = -2
            scene.add(mesh)
        }

        NetworkTables.addWsConnectionListener((connected) => {
            if (connected) {
                // connected
            }
        }, true);

        NetworkTables.addRobotConnectionListener((connected) => {
            if (connected) {
                // connected
            }
        }, true);

        NetworkTables.addKeyListener(`/dashboard/example`, (_, value) => {}, true);

        if (ENABLE_KEYBOARD_CONTROLS) {
            document.onkeydown = (event) => {
                if (!scoring) {
                    if (event.key === `ArrowUp`) currentSelection.y--;
                    if (event.key === `ArrowDown`) currentSelection.y++;
                    if (event.key === `ArrowLeft`) currentSelection.x--;
                    if (event.key === `ArrowRight`) currentSelection.x++;
                    currentSelection.x = Math.min(Math.max(currentSelection.x, 0), 8);
                    currentSelection.y = Math.min(Math.max(currentSelection.y, 0), 2);

                    if (event.key === `Enter`) {
                        startScoring();
                        setTimeout(() => finishScoring(), 2000);
                    }
                }
            };
        }

        animate();

        window.addEventListener(`resize`, () => {
            updateCameraFrustum();
            renderer.setSize(window.innerWidth, window.innerHeight);
            render();
        });

        function roundedRectangle (x, y, width, height, radius) {
            const shape = new THREE.Shape();
            shape.moveTo(x, y + radius);
            shape.lineTo(x, y + height - radius);
            shape.quadraticCurveTo(x, y + height, x + radius, y + height);
            shape.lineTo(x + width - radius, y + height);
            shape.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
            shape.lineTo(x + width, y + radius);
            shape.quadraticCurveTo(x + width, y, x + width - radius, y);
            shape.lineTo(x + radius, y);
            shape.quadraticCurveTo(x, y, x, y + radius);
            return new THREE.ShapeGeometry(shape)
        }

        async function loadSTL (path) {
            return await new Promise((resolve) => {
                loader.load(path, (geometry) => {
                    resolve(geometry);
                });
            })
        }

        function createMeshFromSTL (geometry) {
            const geometryClone = geometry.clone();
            geometryClone.deleteAttribute(`normal`);
            geometryClone.deleteAttribute(`uv`);

            const position = geometryClone.attributes.position;
            const centers = new Float32Array(position.count * 3);
            const vectors = [
                new THREE.Vector3(1, 0, 0),
                new THREE.Vector3(0, 1, 0),
                new THREE.Vector3(0, 0, 1)
            ];

            for (let i = 0, l = position.count; i < l; i++) {
                vectors[i % 3].toArray(centers, i * 3);
            }

            geometryClone.setAttribute(`center`, new THREE.BufferAttribute(centers, 3));
            geometryClone.scale(0.001, 0.001, 0.001)

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    thickness: { value: 1 },
                    color: { type: `vec3`, value: new THREE.Color(0xffffff) }
                },
                vertexShader: document.getElementById(`vertexShader`).textContent,
                fragmentShader: document.getElementById(`fragmentShader`).textContent,
                side: THREE.DoubleSide,
                alphaToCoverage: true
            });
            material.extensions.derivatives = true;

            return new THREE.Mesh(geometryClone, material);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (currentFrustumScale !== 4) {
                currentFrustumScale += (4 - currentFrustumScale) * 0.1;
                updateCameraFrustum();
            }

            selectionOptions.forEach((row, y) => {
                row.forEach((selectionOption, x) => {
                    let rotationDelta;
                    let targetScale;

                    if (currentSelection.x === x && currentSelection.y === y) {
                        if (scoring) {
                            rotationDelta = -0.2;
                            targetScale = 1.6;

                            const alpha = (Math.sin((Date.now() - scoring.since) / 104) + 1) / 2;
                            selectionOption.material.uniforms.color.value.lerpColors(new THREE.Color(0xffffff), new THREE.Color(x % 3 === 1 ? 0xa718b2 : 0xefdf0d), alpha);
                        } else {
                            rotationDelta = -0.02;
                            targetScale = 1.3;
                        }
                    } else {
                        targetScale = 1;
                    }

                    if (typeof rotationDelta === `number`) selectionOption.rotation.y += rotationDelta;
                    else selectionOption.rotation.y = -Math.PI / 6;

                    const newScale = selectionOption.scale.x + ((targetScale - selectionOption.scale.x) * 0.1)
                    selectionOption.scale.set(newScale, newScale, newScale)
                });
            });

            render();
        }

        function render() {
            renderer.render(scene, camera);
        }

        function calculateCameraFrustum () {
            const aspect = window.innerWidth / window.innerHeight;
            return {
                left: currentFrustumScale * aspect / - 2,
                right: currentFrustumScale * aspect / 2,
                top: currentFrustumScale / 2,
                bottom: currentFrustumScale / - 2
            }
        }

        function updateCameraFrustum () {
            const frustum = calculateCameraFrustum();
            camera.left = frustum.left;
            camera.right = frustum.right;
            camera.top = frustum.top;
            camera.bottom = frustum.bottom;
            camera.updateProjectionMatrix();
        }

        function startScoring () {
            scoring = {
                x: currentSelection.x,
                y: currentSelection.y,
                since: Date.now()
            };
        }

        function finishScoring () {
            selectionOptions[scoring.y][scoring.x].material.uniforms.color.value = new THREE.Color(scoring.x % 3 === 1 ? 0xa718b2 : 0xefdf0d);
            scoring = null
        }
    </script>
</body>

</html>
