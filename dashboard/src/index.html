<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>340 Dashboard</title>

    <link rel="icon" type="image/png" href="/assets/favicon.png">

    <style>
        @font-face {
            font-family: 'Library';
            src: url('/assets/fonts/library-webfont.woff2') format('woff2'),
                url('/assets/fonts/library-webfont.woff') format('woff');
            font-weight: normal;
            font-style: normal;
        }

        ::-webkit-scrollbar {
            display: none;
        }

        body {
            margin: 0;
            padding: 0;
            color: white;
            background-color: #292929;
            font-family: 'Library';
            overflow: hidden;
        }

        body canvas {
            position: absolute;
            top: 0;
            z-index: 1000;
        }
    </style>
</head>

<body>
    <!-- Import libs -->
    <script src="/lib/networktables.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "./lib/three.module.js",
                "OrbitControls": "./lib/OrbitControls.module.js",
                "STLLoader": "./lib/STLLoader.module.js",
                "TextSprite": "./lib/TextSprite.module.js"
            }
        }
    </script>

    <!-- Shaders -->
    <script id="vertexShader" type="x-shader/x-vertex">
        attribute vec3 center;
        varying vec3 vCenter;

        void main() {
            vCenter = center;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">
        uniform float thickness;
        uniform vec3 color;
        varying vec3 vCenter;

        void main() {
            vec3 afwidth = fwidth(vCenter.xyz);
            vec3 edge3 = smoothstep((thickness - 1.0) * afwidth, thickness * afwidth, vCenter.xyz);
            float edge = 1.0 - min(min(edge3.x, edge3.y), edge3.z);
            gl_FragColor.rgb = gl_FrontFacing ? color : vec3(color.x * 0.5, color.y * 0.5, color.z * 0.5);
            gl_FragColor.a = edge;
        }
    </script>

    <!-- Logic -->
    <script type="module">
        const ENABLE_ORBIT_CONTROLS = false;
        const ENABLE_KEYBOARD_DEBUGGING = false;

        import * as THREE from 'three';
        import { OrbitControls } from 'OrbitControls';
        import { STLLoader } from 'STLLoader'
        import TextSprite from 'TextSprite';

        let scoring = null
        let currentFrustumScale = 1000;
        const currentSelection = {
            x: 0,
            y: 0
        };

        const loader = new STLLoader();

        const renderer = new THREE.WebGLRenderer({
            alpha: true,
            antialias: true
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const frustum = calculateCameraFrustum(currentFrustumScale);
        const camera = new THREE.OrthographicCamera(frustum.left, frustum.right, frustum.top, frustum.bottom, 1, 100);
        camera.position.z = 10;

        const raycaster = new THREE.Raycaster();

        const scene = new THREE.Scene();

        const coneSTL = await loadSTL(`./assets/models/cone.stl`);
        const cubeSTL = await loadSTL(`./assets/models/cube.stl`);

        const selectionOptions = [];
        for (let i = 0; i < 3; i++) {
            selectionOptions.push([]);
            for (let j = 0; j < 9; j++) {
                const mesh = j % 3 === 1 ? createMeshFromSTL(cubeSTL) : createMeshFromSTL(coneSTL);
                mesh.position.set((j * 0.75) - 3, (i * -0.5) + 1.55, 0);
                mesh.rotation.set(Math.PI / 6, -Math.PI / 6, 0);
                mesh.optionData = { x: j, y: i }
                scene.add(mesh);
                selectionOptions[i].push(mesh);
            }
        }

        const robotModels = await {
            driveBase: createMeshFromSTL(await loadSTL(`./assets/models/drivebase.stl`)),
            spindexer: createMeshFromSTL(await loadSTL(`./assets/models/spindexer.stl`)),
            shoulder: createMeshFromSTL(await loadSTL(`./assets/models/shoulder.stl`)),
            elbow: createMeshFromSTL(await loadSTL(`./assets/models/elbow.stl`)),
            wrist: createMeshFromSTL(await loadSTL(`./assets/models/wrist.stl`)),
            clawLeft: createMeshFromSTL(await loadSTL(`./assets/models/clawleft.stl`)),
            clawRight: createMeshFromSTL(await loadSTL(`./assets/models/clawright.stl`)),
            intake: createMeshFromSTL(await loadSTL(`./assets/models/intake.stl`)),
            intakeWheels: createMeshFromSTL(await loadSTL(`./assets/models/intakeWheels.stl`))
        }

        Object.values(robotModels).forEach((model) => {
            model.position.set(0, -1.5, 0);
            model.rotation.set(Math.PI / 6, Math.PI / 4, Math.PI);
            model.scale.set(1.2, 1.2, 1.2);
            scene.add(model);
        });

        const selectionOptionBackgrounds = [];
        for (let i = 0; i < 3; i++) {
            const mesh = new THREE.Mesh(
                roundedRectangle((i * 2.25) - 3.3125, 0.125, 2.125, 1.75, 0.2),
                    new THREE.MeshBasicMaterial({
                    color: new THREE.Color(0x000000),
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.DoubleSide
                })
            );
            mesh.position.z = -2;
            scene.add(mesh);
            selectionOptionBackgrounds.push(mesh);
        }

        const voltageText = new TextSprite(`0V`, 0.3, `#ffffff`);
        voltageText.fontSize = 100;
        voltageText.fontFace = `'Library'`;
        voltageText.position.set(-2.4375, -0.675, 0);
        scene.add(voltageText);

        const psiText = new TextSprite(`0 PSI`, 0.3, `#ffffff`);
        voltageText.fontSize = 100;
        psiText.fontFace = `'Library'`;
        psiText.position.set(-2.4375, -1.075, 0);
        scene.add(psiText);

        const timerText = new TextSprite(`0:00`, 0.3, `#ffffff`);
        voltageText.fontSize = 100;
        timerText.fontFace = `'Library'`;
        timerText.position.set(2.4375, -0.875, 0);
        scene.add(timerText);

        for (let i = 0; i < 2; i++) {
            scene.add(
            new THREE.Mesh(roundedRectangle(i === 0 ? -3.3125 : 1.5625, -1.75, 1.75, 1.75, 0.2),
            new THREE.MeshBasicMaterial({
                color: new THREE.Color(0x000000),
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            }))
        );
        }

        // TODO connection UI

        // pynetworktables2js websocket connection
        NetworkTables.addWsConnectionListener((connected) => {
            if (connected) {
                console.log(`pynetworktables2js websocket connected`);
            } else {
                console.log(`pynetworktables2js websocket disconnected`)
            }
        }, true);

        // Connection from pynetworktables2js to robot via NetworkTables
        NetworkTables.addRobotConnectionListener((connected) => {
            if (connected) {
                console.log(`Robot NetworkTables connected`);
            } else {
                console.log(`Robot NetworkTables disconnected`);
            }
        }, true);

        // Integer enum: 0 = Red, 1 = Blue, 2 = Invalid
        NetworkTables.addKeyListener(`/dashboard/general/alliance`, (_, value) => {
            if (typeof value === `number`) {
                selectionOptionBackgrounds.forEach((background, i) => {
                    if (i !== 1) {
                        background.material.color = value === 0 ? new THREE.Color(0xff0000) : (value === 1 ? new THREE.Color(0x0000ff) : new THREE.Color(0x000000));
                    }
                });
            }
        }, true);

        // Double: voltage
        NetworkTables.addKeyListener(`/dashboard/general/voltage`, (_, value) => {
            if (typeof value === `number`) {
                voltageText.text = `${Math.round(value * 10) / 10}V`;
            };
        }, true);

        // Integer: PSI
        NetworkTables.addKeyListener(`/dashboard/general/psi`, (_, value) => {
            if (typeof value === `number`) {
                psiText.text = `${value} PSI`;
            }
        }, true);

        // Integer: match time in seconds
        NetworkTables.addKeyListener(`/dashboard/general/time`, (_, value) => {
            if (typeof value === `number` && value >= 0 && value <= 300) {
                timerText.text = new Date(value * 1000).toISOString().substring(15, 19);
            }
        });

        // Integer tuple: [grid, column, row]
        NetworkTables.addKeyListener(`/dashboard/target/selection`, (_, value) => {
            if (value instanceof Array) {
                currentSelection.x = (value[0] * 3) + value[1];
                currentSelection.y = value[2];
            }
        }, true);

        // Boolean: true = scoring, false = finished scoring
        NetworkTables.addKeyListener(`/dashboard/target/scoring`, (_, value) => {
            if (value) startScoring();
            else finishScoring();
        }, false);

        // TODO implement posing robot model

        window.addEventListener(`resize`, () => {
            updateCameraFrustum();
            renderer.setSize(window.innerWidth, window.innerHeight);
            render();
        });

        document.addEventListener(`click`, (event) => {
            const x = (event.clientX / window.innerWidth) * 2 - 1;
            const y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera({ x, y }, camera);
            const raycasterIntersects = raycaster.intersectObjects(scene.children, false)?.filter((mesh) => selectionOptions.flat().includes(mesh.object))[0]?.object;

            if (raycasterIntersects) {
                currentSelection.x = raycasterIntersects.optionData.x;
                currentSelection.y = raycasterIntersects.optionData.y;

                NetworkTables.putValue(`/dashboard/target/selection`, [Math.floor(currentSelection.x / 3), currentSelection.x % 3, currentSelection.y]);
            }
        });

        if (ENABLE_KEYBOARD_DEBUGGING) {
            document.onkeydown = (event) => {
                if (!scoring) {
                    if (event.key === `ArrowUp`) currentSelection.y--;
                    if (event.key === `ArrowDown`) currentSelection.y++;
                    if (event.key === `ArrowLeft`) currentSelection.x--;
                    if (event.key === `ArrowRight`) currentSelection.x++;
                    currentSelection.x = Math.min(Math.max(currentSelection.x, 0), 8);
                    currentSelection.y = Math.min(Math.max(currentSelection.y, 0), 2);

                    if (event.key === `Enter`) {
                        startScoring();
                        setTimeout(() => finishScoring(), 2000);
                    }
                }
            };
        }

        if (ENABLE_ORBIT_CONTROLS) {
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enablePan = false;
            controls.enableZoom = true;
        }

        animate();

        function roundedRectangle (x, y, width, height, radius) {
            const shape = new THREE.Shape();
            shape.moveTo(x, y + radius);
            shape.lineTo(x, y + height - radius);
            shape.quadraticCurveTo(x, y + height, x + radius, y + height);
            shape.lineTo(x + width - radius, y + height);
            shape.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
            shape.lineTo(x + width, y + radius);
            shape.quadraticCurveTo(x + width, y, x + width - radius, y);
            shape.lineTo(x + radius, y);
            shape.quadraticCurveTo(x, y, x, y + radius);
            return new THREE.ShapeGeometry(shape)
        }

        async function loadSTL (path) {
            return await new Promise((resolve) => {
                loader.load(path, (geometry) => {
                    resolve(geometry);
                });
            })
        }

        function createMeshFromSTL (geometry) {
            const geometryClone = geometry.clone();
            geometryClone.deleteAttribute(`normal`);
            geometryClone.deleteAttribute(`uv`);

            const position = geometryClone.attributes.position;
            const centers = new Float32Array(position.count * 3);
            const vectors = [
                new THREE.Vector3(1, 0, 0),
                new THREE.Vector3(0, 1, 0),
                new THREE.Vector3(0, 0, 1)
            ];

            for (let i = 0, l = position.count; i < l; i++) {
                vectors[i % 3].toArray(centers, i * 3);
            }

            geometryClone.setAttribute(`center`, new THREE.BufferAttribute(centers, 3));
            geometryClone.scale(0.001, 0.001, 0.001)

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    thickness: { value: 1 },
                    color: { type: `vec3`, value: new THREE.Color(0xffffff) }
                },
                vertexShader: document.getElementById(`vertexShader`).textContent,
                fragmentShader: document.getElementById(`fragmentShader`).textContent,
                side: THREE.DoubleSide,
                alphaToCoverage: true
            });
            material.extensions.derivatives = true;

            return new THREE.Mesh(geometryClone, material);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (currentFrustumScale !== 4) {
                currentFrustumScale += (4 - currentFrustumScale) * 0.15;
                updateCameraFrustum();
            }

            selectionOptions.forEach((row, y) => {
                row.forEach((selectionOption, x) => {
                    let rotationDelta;
                    let targetScale;

                    if (currentSelection.x === x && currentSelection.y === y) {
                        if (scoring) {
                            rotationDelta = -0.3;
                            targetScale = 1.6;

                            const alpha = (Math.sin((Date.now() - scoring.since) / 75) + 1) / 2;
                            selectionOption.material.uniforms.color.value.lerpColors(new THREE.Color(0xffffff), new THREE.Color(x % 3 === 1 ? 0xa718b2 : 0xefdf0d), alpha);
                        } else {
                            rotationDelta = -0.04;
                            targetScale = 1.3;
                        }
                    } else {
                        targetScale = 1;
                    }

                    if (typeof rotationDelta === `number`) selectionOption.rotation.y += rotationDelta;
                    else selectionOption.rotation.y = -Math.PI / 6;

                    const newScale = selectionOption.scale.x + ((targetScale - selectionOption.scale.x) * 0.125)
                    selectionOption.scale.set(newScale, newScale, newScale)
                });
            });

            render();
        }

        function render() {
            renderer.render(scene, camera);
        }

        function calculateCameraFrustum () {
            const aspect = window.innerWidth / window.innerHeight;
            return {
                left: currentFrustumScale * aspect / - 2,
                right: currentFrustumScale * aspect / 2,
                top: currentFrustumScale / 2,
                bottom: currentFrustumScale / - 2
            }
        }

        function updateCameraFrustum () {
            const frustum = calculateCameraFrustum();
            camera.left = frustum.left;
            camera.right = frustum.right;
            camera.top = frustum.top;
            camera.bottom = frustum.bottom;
            camera.updateProjectionMatrix();
        }

        function startScoring () {
            scoring = {
                x: currentSelection.x,
                y: currentSelection.y,
                since: Date.now()
            };
        }

        function finishScoring () {
            if (scoring && selectionOptions[scoring.y] && selectionOptions[scoring.y][scoring.x]) selectionOptions[scoring.y][scoring.x].material.uniforms.color.value = new THREE.Color(scoring.x % 3 === 1 ? 0xa718b2 : 0xefdf0d);
            scoring = null;
        }
    </script>
</body>

</html>
